/*
 * Generated by erpcgen 1.7.4 on Thu Jun  3 17:44:56 2021.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#include "erpc_port.h"
#include "erpc_codec.h"
extern "C"
{
#include "lprf_cbk.h"
// import callbacks declaration from other groups
#include "lprf_api.h"
}

#if 10704 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

//extern ClientManager *g_client;
ClientManager *lprf_cbk_cm;

//! @brief Function to write struct bt_mesh_msg_ctx_raw
static void write_bt_mesh_msg_ctx_raw_struct(erpc::Codec * codec, const bt_mesh_msg_ctx_raw * data);

//! @brief Function to write struct net_buf_simple_raw
static void write_net_buf_simple_raw_struct(erpc::Codec * codec, const net_buf_simple_raw * data);

//! @brief Function to write struct bt_mesh_hb_sub
static void write_bt_mesh_hb_sub_struct(erpc::Codec * codec, const bt_mesh_hb_sub * data);


// Write struct bt_mesh_msg_ctx_raw function implementation
static void write_bt_mesh_msg_ctx_raw_struct(erpc::Codec * codec, const bt_mesh_msg_ctx_raw * data)
{
    codec->write(data->net_idx);

    codec->write(data->app_idx);

    codec->write(data->addr);

    codec->write(data->recv_dst);

    codec->write(data->recv_rssi);

    codec->write(data->recv_ttl);

    codec->write(data->send_rel);

    codec->write(data->send_ttl);
}

// Write struct net_buf_simple_raw function implementation
static void write_net_buf_simple_raw_struct(erpc::Codec * codec, const net_buf_simple_raw * data)
{
    codec->startWriteList(data->len);
    for (uint32_t listCount0 = 0; listCount0 < data->len; ++listCount0)
    {
        codec->write(data->data[listCount0]);
    }

    codec->write(data->size);

    codec->write(*data->__buf);
}

// Write struct bt_mesh_hb_sub function implementation
static void write_bt_mesh_hb_sub_struct(erpc::Codec * codec, const bt_mesh_hb_sub * data)
{
    codec->write(data->period);

    codec->write(data->remaining);

    codec->write(data->src);

    codec->write(data->dst);

    codec->write(data->count);

    codec->write(data->min_hops);

    codec->write(data->max_hops);
}



// BLEmesh_cbk_access interface start_cb function client shim.
void start_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_start_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_start_cb_id);

    return;
}

// BLEmesh_cbk_access interface init_cb function client shim.
void init_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_init_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_init_cb_id);

    return;
}

// BLEmesh_cbk_access interface reset_cb function client shim.
void reset_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_reset_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_reset_cb_id);

    return;
}

// BLEmesh_cbk_access interface settings_set_cb function client shim.
void settings_set_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index, const char * name, const uint8_t * data, uint8_t data_len)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_settings_set_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        codec->writeString(strlen(name), name);

        codec->startWriteList(data_len);
        for (uint32_t listCount0 = 0; listCount0 < data_len; ++listCount0)
        {
            codec->write(data[listCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_settings_set_cb_id);

    return;
}

// BLEmesh_cbk_access interface update_cb function client shim.
void update_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_update_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_update_cb_id);

    return;
}

// BLEmesh_cbk_access interface func_cb function client shim.
void func_cb(uint32_t opcode, uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index, bt_mesh_msg_ctx_raw * ctx, net_buf_simple_raw * buf)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_func_cb_id, request.getSequence());

        codec->write(opcode);

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        codec->startWriteList(1);
        for (uint32_t listCount0 = 0; listCount0 < 1; ++listCount0)
        {
            write_bt_mesh_msg_ctx_raw_struct(codec, &(ctx[listCount0]));
        }

        codec->startWriteList(1);
        for (uint32_t listCount1 = 0; listCount1 < 1; ++listCount1)
        {
            write_net_buf_simple_raw_struct(codec, &(buf[listCount1]));
        }

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_func_cb_id);

    return;
}

// BLEmesh_cbk_health_srv interface fault_get_cur_cb function client shim.
int32_t fault_get_cur_cb(uint16_t elem_idx, uint16_t model_index, uint8_t * test_id, uint16_t * company_id, uint8_t * faults, uint8_t * fault_count)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_get_cur_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(test_id);

        codec->read(company_id);

        uint32_t lengthTemp_0;
        codec->startReadList(&lengthTemp_0);
        *fault_count = lengthTemp_0;
        if (lengthTemp_0 <= 256)
        {
            for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
            {
                codec->read(&faults[listCount0]);
            }
        }
        else
        {
            codec->updateStatus(kErpcStatus_Fail);
        }

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_get_cur_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface fault_get_reg_cb function client shim.
int32_t fault_get_reg_cb(uint16_t elem_idx, uint16_t model_index, uint16_t company_id, uint8_t * test_id, uint8_t * faults, uint8_t * fault_count)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_get_reg_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        codec->write(company_id);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(test_id);

        uint32_t lengthTemp_0;
        codec->startReadList(&lengthTemp_0);
        *fault_count = lengthTemp_0;
        if (lengthTemp_0 <= 256)
        {
            for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
            {
                codec->read(&faults[listCount0]);
            }
        }
        else
        {
            codec->updateStatus(kErpcStatus_Fail);
        }

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_get_reg_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface fault_clear_cb function client shim.
int32_t fault_clear_cb(uint16_t elem_idx, uint16_t model_index, uint16_t company_id)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_clear_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        codec->write(company_id);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_clear_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface fault_test_cb function client shim.
int32_t fault_test_cb(uint16_t elem_idx, uint16_t model_index, uint8_t test_id, uint16_t company_id)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_test_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        codec->write(test_id);

        codec->write(company_id);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_test_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface attn_on_cb function client shim.
void attn_on_cb(uint16_t elem_idx, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_attn_on_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_attn_on_cb_id);

    return;
}

// BLEmesh_cbk_health_srv interface attn_off_cb function client shim.
void attn_off_cb(uint16_t elem_idx, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_attn_off_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_attn_off_cb_id);

    return;
}

// BLEmesh_cbk interface output_number_cb function client shim.
void output_number_cb(bt_mesh_output_action act, uint32_t num)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_output_number_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(act));

        codec->write(num);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_output_number_cb_id);

    return;
}

// BLEmesh_cbk interface output_string_cb function client shim.
void output_string_cb(const char * str)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_output_string_cb_id, request.getSequence());

        codec->writeString(strlen(str), str);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_output_string_cb_id);

    return;
}

// BLEmesh_cbk interface input_cb function client shim.
void input_cb(bt_mesh_input_action act, uint8_t size)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_input_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(act));

        codec->write(size);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_input_cb_id);

    return;
}

// BLEmesh_cbk interface input_complete_cb function client shim.
void input_complete_cb(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_input_complete_cb_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_input_complete_cb_id);

    return;
}

// BLEmesh_cbk interface unprovisioned_beacon_cb function client shim.
void unprovisioned_beacon_cb(uint8_t uuid[16], bt_mesh_prov_oob_info oob_info, uint32_t * uri_hash)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_unprovisioned_beacon_cb_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(uuid[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(oob_info));

        codec->startWriteList(1);
        for (uint32_t listCount0 = 0; listCount0 < 1; ++listCount0)
        {
            codec->write(uri_hash[listCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_unprovisioned_beacon_cb_id);

    return;
}

// BLEmesh_cbk interface link_open_cb function client shim.
void link_open_cb(bt_mesh_prov_bearer bearer)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_link_open_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(bearer));

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_link_open_cb_id);

    return;
}

// BLEmesh_cbk interface link_close_cb function client shim.
void link_close_cb(bt_mesh_prov_bearer bearer)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_link_close_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(bearer));

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_link_close_cb_id);

    return;
}

// BLEmesh_cbk interface complete_cb function client shim.
void complete_cb(uint16_t net_idx, uint16_t addr)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_complete_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(addr);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_complete_cb_id);

    return;
}

// BLEmesh_cbk interface node_added_cb function client shim.
void node_added_cb(uint16_t net_idx, uint8_t uuid[16], uint16_t addr, uint8_t num_elem)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_node_added_cb_id, request.getSequence());

        codec->write(net_idx);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(uuid[arrayCount0]);
        }

        codec->write(addr);

        codec->write(num_elem);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_node_added_cb_id);

    return;
}

// BLEmesh_cbk interface reset_prov_cb function client shim.
void reset_prov_cb(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_reset_prov_cb_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_reset_prov_cb_id);

    return;
}

// BLEmesh_cbk interface hb_recv_cb function client shim.
void hb_recv_cb(const bt_mesh_hb_sub * sub, uint8_t hops, uint16_t feat)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_hb_recv_cb_id, request.getSequence());

        write_bt_mesh_hb_sub_struct(codec, sub);

        codec->write(hops);

        codec->write(feat);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_hb_recv_cb_id);

    return;
}

// BLEmesh_cbk interface hb_sub_end_cb function client shim.
void hb_sub_end_cb(const bt_mesh_hb_sub * sub)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_hb_sub_end_cb_id, request.getSequence());

        write_bt_mesh_hb_sub_struct(codec, sub);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_hb_sub_end_cb_id);

    return;
}

// BLEmesh_cbk interface lpn_friendship_established_cb function client shim.
void lpn_friendship_established_cb(uint16_t net_idx, uint16_t friend_addr, uint8_t queue_size, uint8_t recv_window)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_lpn_friendship_established_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(friend_addr);

        codec->write(queue_size);

        codec->write(recv_window);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_lpn_friendship_established_cb_id);

    return;
}

// BLEmesh_cbk interface lpn_friendship_terminated_cb function client shim.
void lpn_friendship_terminated_cb(uint16_t net_idx, uint16_t friend_addr)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_lpn_friendship_terminated_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(friend_addr);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_lpn_friendship_terminated_cb_id);

    return;
}

// BLEmesh_cbk interface lpn_polled_cb function client shim.
void lpn_polled_cb(uint16_t net_idx, uint16_t friend_addr, bool retry)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_lpn_polled_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(friend_addr);

        codec->write(retry);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_lpn_polled_cb_id);

    return;
}

// BLEmesh_cbk interface friend_friendship_established_cb function client shim.
void friend_friendship_established_cb(uint16_t net_idx, uint16_t lpn_addr, uint8_t recv_delay, uint32_t polltimeout)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_friend_friendship_established_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(lpn_addr);

        codec->write(recv_delay);

        codec->write(polltimeout);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_friend_friendship_established_cb_id);

    return;
}

// BLEmesh_cbk interface friend_friendship_terminated_cb function client shim.
void friend_friendship_terminated_cb(uint16_t net_idx, uint16_t lpn_addr)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_friend_friendship_terminated_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(lpn_addr);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_friend_friendship_terminated_cb_id);

    return;
}

// BLEmesh_cbk interface appkey_evt_cb function client shim.
void appkey_evt_cb(uint16_t app_idx, uint16_t net_idx, bt_mesh_key_evt evt)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_appkey_evt_cb_id, request.getSequence());

        codec->write(app_idx);

        codec->write(net_idx);

        codec->write(static_cast<int32_t>(evt));

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_appkey_evt_cb_id);

    return;
}
