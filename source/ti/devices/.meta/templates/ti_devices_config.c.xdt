%%{
/*
 * Copyright (c) 2019-2021 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *  ======== ti_devices_config.c.xdt ========
 */

    var module = system.modules['/ti/devices/CCFG'];
    var inst = module.$static;

%%}
/*
 *  ======== ti_devices_config.c ========
 *  Customer Configuration for CC26XX and CC13XX devices.
 *
 *  DO NOT EDIT - This file is generated by the SysConfig tool.
 *
 */

//#####################################
// Force VDDR high setting (Higher output power but also higher power consumption)
// This is also called "boost mode"
//#####################################

% if(inst.forceVddr){
// Force VDDR voltage to the factory HH setting (FCFG1..VDDR_TRIM_HH)
#define CCFG_FORCE_VDDR_HH                              0x1
% } else {
// Use default VDDR trim
#define CCFG_FORCE_VDDR_HH                              0x0
% }


//#####################################
// Power settings
//#####################################

% if(inst.enableDCDC) {
// Use the DC/DC during recharge in powerdown
#define SET_CCFG_MODE_CONF_DCDC_RECHARGE                0x0

// Use the DC/DC during active mode
#define SET_CCFG_MODE_CONF_DCDC_ACTIVE                  0x0
% } else {
// Do not use the DC/DC during recharge in powerdown
#define SET_CCFG_MODE_CONF_DCDC_RECHARGE                0x1

// Do not use the DC/DC during active mode
#define SET_CCFG_MODE_CONF_DCDC_ACTIVE                  0x1
% }


//#####################################
// Clock settings
//#####################################

% if(inst.srcClkLF === 'Derived from HF XOSC') {
// LF clock derived from High Frequency XOSC
#define SET_CCFG_MODE_CONF_SCLK_LF_OPTION               0x0
% }
% else if(inst.srcClkLF === 'External LF clock') {
% const extclkdiohex = inst.extClkDio.toString(16);
% const rtcinchex = inst.rtcIncrement.toString(16);
// External LF clock
#define SET_CCFG_MODE_CONF_SCLK_LF_OPTION               0x1

// DIO number if using external LF clock
#define SET_CCFG_EXT_LF_CLK_DIO                         0x`extclkdiohex`

// RTC increment representing the external LF clock frequency
#define SET_CCFG_EXT_LF_CLK_RTC_INCREMENT               0x`rtcinchex`
% }
% else if(inst.srcClkLF === 'LF XOSC') {
// LF XOSC
#define SET_CCFG_MODE_CONF_SCLK_LF_OPTION               0x2
% }
% else if(inst.srcClkLF === 'LF RCOSC') {
// LF RCOSC
#define SET_CCFG_MODE_CONF_SCLK_LF_OPTION               0x3
% }

% if(inst.xoscCapArray) {
% const capArrDelta = inst.xoscCapArrayDelta.toString(16);
// Apply cap-array delta
#define SET_CCFG_MODE_CONF_XOSC_CAP_MOD                 0x0
#define SET_CCFG_MODE_CONF_XOSC_CAPARRAY_DELTA          0x`capArrDelta`
% } else {
// Don't apply cap-array delta
#define SET_CCFG_MODE_CONF_XOSC_CAP_MOD                 0x1
% }

//#####################################
// Special HF clock source setting
//#####################################

% if(inst.srcClkHF === "48 MHz XOSC_HF") {
// HF source is a 48 MHz xtal
#define SET_CCFG_MODE_CONF_XOSC_FREQ                    0x2
% } else if(inst.srcClkHF === "Internal High Precision Oscillator"){
// HF source is HPOSC (BAW) (only valid for CC2652RB)
#define SET_CCFG_MODE_CONF_XOSC_FREQ                    0x1
% } else if(inst.srcClkHF === "External 48Mhz TCXO"){
// HF source is 48 MHz TCXO
#define SET_CCFG_MODE_CONF_XOSC_FREQ                    0x0
% const tcxoType = inst.tcxoType === "CMOS Type" ? 0 : 1;
% const tcxoMaxStart = inst.tcxoMaxStartup.toString(16);
// 0 = CMOS type, 1 = Clipped-sine type
#define SET_CCFG_MODE_CONF_1_TCXO_TYPE                  0x`tcxoType`
// Maximum TCXO startup time in units of 100us.
#define SET_CCFG_MODE_CONF_1_TCXO_MAX_START             0x`tcxoMaxStart`
%}

//#####################################
// Bootloader settings
//#####################################

% if(inst.enableBootloader) {
// Enable ROM boot loader
#define SET_CCFG_BL_CONFIG_BOOTLOADER_ENABLE            0xC5

    % if(inst.enableBootloaderBackdoor) {
// Enabled boot loader backdoor
#define SET_CCFG_BL_CONFIG_BL_ENABLE                    0xC5

        % var diohex = inst.dioBootloaderBackdoor.toString(16);
// DIO number for boot loader backdoor
#define SET_CCFG_BL_CONFIG_BL_PIN_NUMBER                0x`diohex`

        % if(inst.levelBootloaderBackdoor === 'Active high') {
// Active high to open boot loader backdoor
#define SET_CCFG_BL_CONFIG_BL_LEVEL                     0x1

        % } else {
// Active low to open boot loader backdoor
#define SET_CCFG_BL_CONFIG_BL_LEVEL                     0x0

        % }
    % } else {
// Disabled boot loader backdoor
#define SET_CCFG_BL_CONFIG_BL_ENABLE                    0xFF

    % }
% } else {
// Disable ROM boot loader
#define SET_CCFG_BL_CONFIG_BOOTLOADER_ENABLE            0x00
% }

% if(inst.setFlashVectorTable) {
% var vectTabAddr = inst.addressFlashVectorTable.toString(16);
// Apply address to IMAGE_VALID_CONF register
#define SET_CCFG_IMAGE_VALID_CONF_IMAGE_VALID           0x`vectTabAddr`
% } else {
// Default address in IMAGE_VALID_CONF register
#define SET_CCFG_IMAGE_VALID_CONF_IMAGE_VALID           0x00000000
% }

//#####################################
// Debug access settings
//#####################################

% if (inst.FailureAnalysis){
// Enable unlocking of TI FA option with the unlock code
#define SET_CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE           0xC5
% } else {
// Disable unlocking of TI FA option.
#define SET_CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE           0x00
% }

% if (inst.CpuDap){
// Access enabled if also enabled in FCFG
#define SET_CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE          0xC5
% } else {
// Access disabled
#define SET_CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE          0x00
% }

% if (inst.PwrprofTap){
// Access enabled if also enabled in FCFG
#define SET_CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE      0xC5
% } else {
// Access disabled
#define SET_CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE      0x00
% }

% if (inst.TestTap){
// Access enabled if also enabled in FCFG
#define SET_CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE         0xC5
% } else {
// Access disabled
#define SET_CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE         0x00
% }

% if (inst.Pbist2Tap){
// Access enabled if also enabled in FCFG
#define SET_CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE       0xC5
% } else {
// Access disabled
#define SET_CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE       0x00
% }

% if (inst.Pbist1Tap){
// Access enabled if also enabled in FCFG
#define SET_CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE       0xC5
% } else {
// Access disabled
#define SET_CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE       0x00
% }

% if (inst.AonTap){
// Access enabled if also enabled in FCFG
#define SET_CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE          0xC5
% } else {
// Access disabled
#define SET_CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE          0x00
% }

% if(inst.configureIEEE) {
%   var ieee = inst.addressIEEE.replace(/:/g,"");
%   var ieeemac1 = ieee.substr(0, 8).toUpperCase();
%   var ieeemac0 = ieee.substr(8, 8).toUpperCase();
//#####################################
// Alternative IEEE 802.15.4 MAC address
//#####################################

// Bits [31:0]
#define SET_CCFG_IEEE_MAC_0                             0x`ieeemac0`

// Bits [63:32]
#define SET_CCFG_IEEE_MAC_1                             0x`ieeemac1`

% }
% if(inst.configureBLE) {
%   var blemac = inst.addressBLE.replace(/:/g,"");
%   var blemac1 = blemac.substr(0, 8).toUpperCase();
%   var blemac0 = blemac.substr(8, 8).toUpperCase();
//#####################################
// Alternative BLE address
//#####################################

// Bits [31:0]
#define SET_CCFG_IEEE_BLE_0                             0x`blemac0`

// Bits [63:32]
#define SET_CCFG_IEEE_BLE_1                             0x`blemac1`

% }
//#####################################
// Select between cache or GPRAM
//#####################################

% if(inst.disableCache) {
// Cache is disabled and GPRAM is available at 0x11000000-0x11001FFF
#define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM           0x0
% } else {
// Cache is enabled and GPRAM is disabled (unavailable)
#define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM           0x1
% }

% const device = system.deviceData.deviceId;
% if(device.match(/CC(?:13|26).4/)) {
% if (inst.configureIDAU || inst.disableRamParity) {
//#####################################
// Trustzone settings
//#####################################

% if(inst.configureIDAU) {
% if(inst.markAllFlashSecure) {
// Set all of flash to secure-only access, using the special value of 0
#define SET_CCFG_TRUSTZONE_FLASH_CFG_NSADDR_BOUNDARY    0x0
% } else {
% const nsaddr_value = (inst.flashNonsecureBoundary / 0x2000).toString(16);
// Non-secure access boundary, configured in 8KB steps
#define SET_CCFG_TRUSTZONE_FLASH_CFG_NSADDR_BOUNDARY    0x`nsaddr_value`
% }

% const nscaddr_value = (inst.flashNonsecureCallableBoundary / 0x400).toString(16);
// Non-secure callable access boundary, configured in 1KB steps
#define SET_CCFG_TRUSTZONE_FLASH_CFG_NSCADDR_BOUNDARY   0x`nscaddr_value`

% const ramnsaddr_value = ((inst.sramNonsecureBoundary - 0x20000000) / 0x400).toString(16);
// Non-secure access boundary, configured in 1KB steps
#define SET_CCFG_TRUSTZONE_SRAM_CFG_NSADDR_BOUNDARY     0x`ramnsaddr_value`

% const ramnscaddr_value = ((inst.sramNonsecureCallableBoundary - 0x20000000) / 0x400).toString(16);
// Non-secure callable access boundary, configured in 1KB steps
#define SET_CCFG_TRUSTZONE_SRAM_CFG_NSCADDR_BOUNDARY    0x`ramnscaddr_value`

% }
% if(inst.disableRamParity) {
// Disable parity (enabled by default)
#define SET_CCFG_SRAM_CFG_PARITY_DIS                    0x0

% }

% }
//#####################################
// Bus security settings
//#####################################

% if(inst.lockNonSecureVectorTableBaseAddress) {
// Enable lock on non-secure vector table base address
#define SET_CCFG_CPU_LOCK_CFG_LOCKNSVTOR               0x0

% }
% if(inst.lockSecureInterruptConfig) {
// Enable lock on secure interrupt config
#define SET_CCFG_CPU_LOCK_CFG_LOCKSVTAIRCR             0x0

% }
% if(inst.lockSAURegions) {
// Enable lock on SAU regions
#define SET_CCFG_CPU_LOCK_CFG_LOCKSAU                  0x0

% }
% if(inst.lockNonSecureMPU) {
// Enable lock on non-secure MPU
#define SET_CCFG_CPU_LOCK_CFG_LOCKNSMPU                0x0

% }
% if(inst.lockSecureMPU) {
// Enable lock on secure MPU
#define SET_CCFG_CPU_LOCK_CFG_LOCKSMPU                 0x0

% }
% if(inst.disableSecureNonInvasiveDebug || inst.disableSecureInvasiveDebug) {
//#####################################
// Debug authentication settings
//#####################################

% if(inst.disableSecureNonInvasiveDebug) {
// Internal secure non-invasive debug disable
#define SET_CCFG_DEB_AUTH_CFG_INTSPNIDEN               0x0
// Internal secure non-invasive debug deselect
#define SET_CCFG_DEB_AUTH_CFG_SPNIDENSEL               0x0

% }
% if(inst.disableSecureInvasiveDebug) {
// Internal secure invasive debug disable
#define SET_CCFG_DEB_AUTH_CFG_INTSPIDEN                0x0
// Internal secure invasive debug deselect
#define SET_CCFG_DEB_AUTH_CFG_SPIDENSEL                0x0

% }
% }
% } // End of CC26X4-specific section
/*
 *  ======== Include Base Settings for device ========
 */

#include <ti/devices/DeviceFamily.h>
#include DeviceFamily_constructPath(startup_files/ccfg.c)
